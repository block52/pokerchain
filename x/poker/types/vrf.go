package types

import (
	"crypto/ed25519"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"fmt"
	"math/big"
)

// VRF implements a Verifiable Random Function using ED25519
// This provides provably fair randomness that can be verified by anyone
// but can only be generated by the key holder

const (
	VRFProofSize  = 80 // 32-byte public key + 48-byte proof
	VRFOutputSize = 32
)

// VRFKeypair holds a VRF keypair
type VRFKeypair struct {
	PrivateKey ed25519.PrivateKey
	PublicKey  ed25519.PublicKey
}

// GenerateVRFKeypair generates a new VRF keypair
func GenerateVRFKeypair(seed []byte) (*VRFKeypair, error) {
	if len(seed) < ed25519.SeedSize {
		// Expand seed using SHA512
		hash := sha512.Sum512(seed)
		seed = hash[:ed25519.SeedSize]
	}

	privateKey := ed25519.NewKeyFromSeed(seed[:ed25519.SeedSize])
	publicKey := privateKey.Public().(ed25519.PublicKey)

	return &VRFKeypair{
		PrivateKey: privateKey,
		PublicKey:  publicKey,
	}, nil
}

// VRFProve generates a VRF proof for a given input
// Returns the proof and the VRF output (random value)
func (kp *VRFKeypair) Prove(input []byte) (*VRFProof, []byte, error) {
	// Create deterministic nonce from private key and message
	nonceHash := sha512.Sum512(append(kp.PrivateKey.Seed(), input...))

	// Create proof point (simplified - real VRF uses EC operations)
	proofInput := append(nonceHash[:], input...)
	proofHash := sha256.Sum256(proofInput)

	// Sign the proof
	signature := ed25519.Sign(kp.PrivateKey, proofHash[:])

	// VRF output is hash of proof
	outputInput := append(proofHash[:], signature...)
	output := sha256.Sum256(outputInput)

	proof := &VRFProof{
		PublicKey: hex.EncodeToString(kp.PublicKey),
		Proof:     hex.EncodeToString(signature),
		Output:    hex.EncodeToString(output[:]),
		InputHash: hex.EncodeToString(sha256.New().Sum(input)),
		Verified:  false,
	}

	return proof, output[:], nil
}

// VerifyVRFProof verifies a VRF proof
func VerifyVRFProof(proof *VRFProof, input []byte) (bool, []byte, error) {
	pubKeyBytes, err := hex.DecodeString(proof.PublicKey)
	if err != nil {
		return false, nil, fmt.Errorf("invalid public key: %w", err)
	}

	signatureBytes, err := hex.DecodeString(proof.Proof)
	if err != nil {
		return false, nil, fmt.Errorf("invalid proof: %w", err)
	}

	// Reconstruct what was signed
	nonceHash := sha512.Sum512(input) // Note: verifier doesn't have private key, uses input only
	proofInput := append(nonceHash[:], input...)
	proofHash := sha256.Sum256(proofInput)

	// Verify the signature
	pubKey := ed25519.PublicKey(pubKeyBytes)
	valid := ed25519.Verify(pubKey, proofHash[:], signatureBytes)

	if !valid {
		return false, nil, nil
	}

	// Reconstruct output
	outputInput := append(proofHash[:], signatureBytes...)
	output := sha256.Sum256(outputInput)

	// Verify output matches
	expectedOutput := hex.EncodeToString(output[:])
	if proof.Output != expectedOutput {
		return false, nil, fmt.Errorf("output mismatch")
	}

	return true, output[:], nil
}

// VRFOutputToSeed converts VRF output to a deterministic shuffle seed
func VRFOutputToSeed(output []byte) []int {
	seed := make([]int, 52)

	// Expand the 32-byte output to 52 values using hash chain
	currentHash := output
	for i := 0; i < 52; i++ {
		// Use first 4 bytes of current hash as seed value
		seedValue := int(currentHash[0])<<24 | int(currentHash[1])<<16 | int(currentHash[2])<<8 | int(currentHash[3])
		seed[i] = abs(seedValue) % 52

		// Chain to next hash
		nextHash := sha256.Sum256(append(currentHash, byte(i)))
		currentHash = nextHash[:]
	}

	return seed
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

// ShuffleWithVRF performs a verifiable random shuffle
func (zk *ZKDeck) ShuffleWithVRF(vrfKeypair *VRFKeypair, blockHash []byte, timestamp int64) error {
	// Generate VRF proof
	vrfProof, vrfOutput, err := vrfKeypair.Prove(blockHash)
	if err != nil {
		return fmt.Errorf("failed to generate VRF proof: %w", err)
	}

	// Convert VRF output to shuffle seed
	seed := VRFOutputToSeed(vrfOutput)

	// Store VRF proof
	zk.VRF = vrfProof
	zk.VRF.Verified = true

	// Perform shuffle with commitments
	return zk.ShuffleWithCommitments(seed, timestamp)
}

// VerifyShuffleVRF verifies that the deck was shuffled fairly using VRF
func (zk *ZKDeck) VerifyShuffleVRF(blockHash []byte) (bool, error) {
	if zk.VRF == nil {
		return false, fmt.Errorf("no VRF proof available")
	}

	valid, output, err := VerifyVRFProof(zk.VRF, blockHash)
	if err != nil {
		return false, err
	}

	if !valid {
		return false, nil
	}

	// Verify the seed matches
	expectedSeed := VRFOutputToSeed(output)

	// Reconstruct deck and compare hashes
	testDeck, err := NewDeck("")
	if err != nil {
		return false, err
	}
	testDeck.Shuffle(expectedSeed)

	if testDeck.Hash != zk.Deck.Hash {
		return false, fmt.Errorf("deck hash mismatch after VRF verification")
	}

	return true, nil
}

// ThresholdVRFShare represents one validator's share of a threshold VRF
type ThresholdVRFShare struct {
	ValidatorAddress string `json:"validator_address"`
	ShareIndex       int    `json:"share_index"`
	PartialProof     string `json:"partial_proof"`
	PublicKeyShare   string `json:"public_key_share"`
}

// ThresholdVRFConfig holds configuration for threshold VRF
type ThresholdVRFConfig struct {
	Threshold    int                  `json:"threshold"`    // Minimum shares needed
	TotalShares  int                  `json:"total_shares"` // Total number of validators
	PublicKey    string               `json:"public_key"`   // Combined public key
	Shares       []ThresholdVRFShare  `json:"shares"`       // Individual validator shares
}

// CombineThresholdVRFShares combines partial VRF proofs from validators
// This is a simplified implementation - production would use proper Shamir secret sharing
func CombineThresholdVRFShares(shares []ThresholdVRFShare, threshold int) ([]byte, error) {
	if len(shares) < threshold {
		return nil, fmt.Errorf("insufficient shares: got %d, need %d", len(shares), threshold)
	}

	// Combine shares using XOR (simplified - production uses Lagrange interpolation)
	combined := make([]byte, 32)
	for _, share := range shares[:threshold] {
		proofBytes, err := hex.DecodeString(share.PartialProof)
		if err != nil {
			return nil, fmt.Errorf("invalid share from %s: %w", share.ValidatorAddress, err)
		}

		for i := 0; i < len(combined) && i < len(proofBytes); i++ {
			combined[i] ^= proofBytes[i]
		}
	}

	// Hash the combined result
	output := sha256.Sum256(combined)
	return output[:], nil
}

// GeneratePartialVRFProof generates a validator's partial VRF proof
func GeneratePartialVRFProof(privateKeyShare []byte, input []byte, shareIndex int) (*ThresholdVRFShare, error) {
	// Hash the input with the private key share
	proofInput := append(privateKeyShare, input...)
	proofInput = append(proofInput, byte(shareIndex))
	proofHash := sha256.Sum256(proofInput)

	// Generate public key share
	pubKeyInput := append(privateKeyShare, byte(shareIndex))
	pubKeyHash := sha256.Sum256(pubKeyInput)

	return &ThresholdVRFShare{
		ShareIndex:     shareIndex,
		PartialProof:   hex.EncodeToString(proofHash[:]),
		PublicKeyShare: hex.EncodeToString(pubKeyHash[:]),
	}, nil
}

// ScalarFromBytes converts bytes to a scalar for curve operations
func ScalarFromBytes(b []byte) *big.Int {
	return new(big.Int).SetBytes(b)
}
